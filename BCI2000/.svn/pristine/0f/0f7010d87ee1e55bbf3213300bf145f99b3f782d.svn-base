Application:Window:CursorFeedbackTask int RenderingQuality= 1 0 0 1 // rendering quality: 0: low, 1: high (enumeration)
Application:Window:CursorFeedbackTask int WindowBitDepth= 16 16 1 32 // color bit depth of feedback window
Application:Sequencing float PreRunDuration= 0s 2s 0 % // duration of pause preceding first trial
Application:Sequencing float PreFeedbackDuration= 240ms 2s 0 % // duration of target display prior to feedback
Application:Sequencing float FeedbackDuration= 1ms 3s 0 % // duration of feedback
Application:Sequencing float PostFeedbackDuration= 0s 1s 0 % // duration of result display after feedback
Application:Sequencing float ITIDuration= 500ms 1s 0 % // duration of inter-trial interval
Application:Sequencing:FeedbackTask float MinRunLength= % 120s 0 % // minimum duration of a run; if blank, NumberOfTrials is used
Application:Sequencing:FeedbackTask int NumberOfTrials= 50 0 0 % // number of trials; if blank, MinRunLength is used
Application:Targets int NumberTargets= 1 2 0 15 // number of targets
Application:Sequencing float MaxFeedbackDuration= 0s % 0 % // abort a trial after this amount of feedback time has expired
Application:3DEnvironment floatlist CameraPos= 3 50 50 150 // camera position vector in percent coordinates of 3D area
Application:3DEnvironment floatlist CameraAim= 3 50 50 50 // camera aim point in percent coordinates
Application:3DEnvironment float CameraProjection= 0 0 0 2 // projection type: 0: flat, 1: wide angle perspective, 2: narrow angle perspective (enumeration)
Application:3DEnvironment floatlist LightSourcePos= 3 50 50 100 // light source position in percent coordinates
Application:3DEnvironment int LightSourceColor= 0x808080 // light source RGB color (color)
Application:3DEnvironment int WorkspaceBoundaryColor= 0xffffff 0 % % // workspace boundary color (0xff000000 for invisible) (color)
Application:3DEnvironment string WorkspaceBoundaryTexture= ../../prog/images/grid.bmp // path of workspace boundary texture (inputfile)
Application:Cursor float CursorWidth= 0 10 0.0 % // feedback cursor width in percent of screen width
Application:Cursor int CursorColorFront= 0xff0000 // cursor color when it is at the front of the workspace (color)
Application:Cursor int CursorColorBack= 0xffff00 // cursor color when it is in the back of the workspace (color)
Application:Cursor string CursorTexture= % // path of cursor texture (inputfile)
Application:Cursor floatlist CursorPos= 3 0 0 0 // cursor starting position
Application:Targets matrix Targets= 1 { pos%20x pos%20y pos%20z width%20x width%20y width%20z } 50 50 50 40 40 8 // target positions and widths in percentage coordinates
Application:Targets int TargetColor= 0xffffff // target color (color)
Application:Targets string TargetTexture= % // path of target texture (inputfile)
Application:Targets int TestAllTargets= 0 0 0 1 // test all targets for cursor collision? 0: test only the visible current target, 1: test all targets (enumeration)
Source:Online%20Processing:TransmissionFilter list TransmitChList= 32 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 1 1 % // list of transmitted channels
Filtering:SpatialFilter matrix SpatialFilter= 32 32 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 % % // columns represent input channels, rows represent output channels
Filtering:ARFilter int WindowLength= 0.5s 0.5s % % // Time window for spectrum computation
Filtering:ARFilter int Detrend= 0 0 0 2 // Detrend data? 0: no, 1: mean, 2: linear (enumeration)
Filtering:ARFilter int ModelOrder= 16 16 0 % // AR model order
Filtering:ARFilter int OutputType= 0 0 0 2 // 0: Spectral Amplitude, 1: Spectral Power, 2: AR Coefficients (enumeration)
Filtering:ARFilter float FirstBinCenter= 0Hz 0Hz % % // Center of first frequency bin (as a fraction of sampling rate or in Hz)
Filtering:ARFilter float LastBinCenter= 30Hz 30Hz % % // Center of last frequency bin (as a fraction of sampling rate or in Hz)
Filtering:ARFilter float BinWidth= 2Hz 3Hz % % // Width of spectral bins (as a fraction of sampling rate or in Hz)
Filtering:ARFilter int EvaluationsPerBin= 15 15 1 % // Number of uniformly spaced evaluation points entering into a single bin value
Filtering:LinearClassifier matrix Classifier= 4 { input%20channel input%20element%20(bin) output%20channel weight } 1 5 1 -1 2 5 1 1 3 5 1 -1 4 5 1 1 // Linear classification matrix in sparse representation
Filtering:LPFilter float LPTimeConstant= 0 16s 0 % // time constant for the low pass filter
Filtering:ExpressionFilter matrix Expressions= 0 1 // expressions used to compute the output of the ExpressionFilter (empty matrix for none)
Filtering:Normalizer floatlist NormalizerOffsets= 2 0 0 0 % % // normalizer offsets
Filtering:Normalizer floatlist NormalizerGains= 2 0 1 0 % % // normalizer gain values
Filtering:Normalizer intlist Adaptation= 2 0 0 0 0 2 // 0: no adaptation, 1: zero mean, 2: zero mean, unit variance (enumeration)
Filtering:Normalizer matrix BufferConditions= 2 1 (Feedback)&&(TargetCode==1) (Feedback)&&(TargetCode==2) // expressions corresponding to data buffers (columns correspond to output channels, multiple rows correspond to multiple buffers)
Filtering:Normalizer float BufferLength= 8s 9s % % // time window of past data per buffer that enters into statistic
Filtering:Normalizer string UpdateTrigger= % // expression to trigger offset/gain update when changing from 0 (use empty string for continuous update)
