// Import definitions for libmex library
// generated Thu Oct 12 16:52:39 2023 by DylibTool
#ifdef STATIC_LIBLIBMEX

namespace Dylib { bool libmex_Loaded() { return true; } }


#else // STATIC_LIBLIBMEX

#include "libmex.imports.h"
#include "DylibImports.h"
namespace { extern const Dylib::Import* functionImports; }

// Here you may specify a custom error message to be displayed when the library cannot be found.
static const char* notFoundMsg = "";
// Here you may specify an URL to some local or remote help resource.
static const char* notFoundURL = "";
RegisterDylibWithAliases( libmex, "libmex", functionImports, notFoundMsg, notFoundURL );
extern "C" {
decltype(&__5d7f3818_mexAtExit_800) mexAtExit_800 = 0;
decltype(&__27017b6a_mexCallMATLABWithTrap_800) mexCallMATLABWithTrap_800 = 0;
decltype(&__3f02607f_mexCallMATLAB_800) mexCallMATLAB_800 = 0;
decltype(&__52653d3f_mexErrMsgIdAndTxt_800) mexErrMsgIdAndTxt_800 = 0;
decltype(&__277b7d72_mexErrMsgTxt_800) mexErrMsgTxt_800 = 0;
decltype(&__202a5e5d_mexEvalStringWithTrap_800) mexEvalStringWithTrap_800 = 0;
decltype(&__38294548_mexEvalString_800) mexEvalString_800 = 0;
decltype(&__28392023_mexFunctionName_800) mexFunctionName_800 = 0;
decltype(&__54422700_mexGetVariablePtr_800) mexGetVariablePtr_800 = 0;
decltype(&__262d107c_mexGetVariable_800) mexGetVariable_800 = 0;
decltype(&__44734879_mexIsGlobal_800) mexIsGlobal_800 = 0;
decltype(&__4d7c4375_mexIsLocked_800) mexIsLocked_800 = 0;
decltype(&__3a362313_mexLock_800) mexLock_800 = 0;
decltype(&__192e255b_mexMakeArrayPersistent_800) mexMakeArrayPersistent_800 = 0;
decltype(&__3e04202b_mexMakeMemoryPersistent_800) mexMakeMemoryPersistent_800 = 0;
decltype(&__7254341e_mexPrintAssertion_800) mexPrintAssertion_800 = 0;
decltype(&__49532e14_mexPrintf_800) mexPrintf_800 = 0;
decltype(&__362d106b_mexPutVariable_800) mexPutVariable_800 = 0;
decltype(&__58562f06_mexUnlock_800) mexUnlock_800 = 0;
decltype(&__765a6412_mexWarnMsgIdAndTxt_800) mexWarnMsgIdAndTxt_800 = 0;
decltype(&__3b2f7a52_mexWarnMsgTxt_800) mexWarnMsgTxt_800 = 0;
} // extern "C"

namespace {
const Dylib::Import functionImports_[] =
{
  { "mexAtExit_800", (void**)&mexAtExit_800, Dylib::Import::cMangled },
  { "mexCallMATLABWithTrap_800", (void**)&mexCallMATLABWithTrap_800, Dylib::Import::cMangled },
  { "mexCallMATLAB_800", (void**)&mexCallMATLAB_800, Dylib::Import::cMangled },
  { "mexErrMsgIdAndTxt_800", (void**)&mexErrMsgIdAndTxt_800, Dylib::Import::cMangled },
  { "mexErrMsgTxt_800", (void**)&mexErrMsgTxt_800, Dylib::Import::cMangled },
  { "mexEvalStringWithTrap_800", (void**)&mexEvalStringWithTrap_800, Dylib::Import::cMangled },
  { "mexEvalString_800", (void**)&mexEvalString_800, Dylib::Import::cMangled },
  { "mexFunctionName_800", (void**)&mexFunctionName_800, Dylib::Import::cMangled },
  { "mexGetVariablePtr_800", (void**)&mexGetVariablePtr_800, Dylib::Import::cMangled },
  { "mexGetVariable_800", (void**)&mexGetVariable_800, Dylib::Import::cMangled },
  { "mexIsGlobal_800", (void**)&mexIsGlobal_800, Dylib::Import::cMangled },
  { "mexIsLocked_800", (void**)&mexIsLocked_800, Dylib::Import::cMangled },
  { "mexLock_800", (void**)&mexLock_800, Dylib::Import::cMangled },
  { "mexMakeArrayPersistent_800", (void**)&mexMakeArrayPersistent_800, Dylib::Import::cMangled },
  { "mexMakeMemoryPersistent_800", (void**)&mexMakeMemoryPersistent_800, Dylib::Import::cMangled },
  { "mexPrintAssertion_800", (void**)&mexPrintAssertion_800, Dylib::Import::cMangled },
  { "mexPrintf_800", (void**)&mexPrintf_800, Dylib::Import::cMangled },
  { "mexPutVariable_800", (void**)&mexPutVariable_800, Dylib::Import::cMangled },
  { "mexUnlock_800", (void**)&mexUnlock_800, Dylib::Import::cMangled },
  { "mexWarnMsgIdAndTxt_800", (void**)&mexWarnMsgIdAndTxt_800, Dylib::Import::cMangled },
  { "mexWarnMsgTxt_800", (void**)&mexWarnMsgTxt_800, Dylib::Import::cMangled },
  { 0, 0, 0 }
};
const Dylib::Import* functionImports = functionImports_;
}

#endif // STATIC_LIBLIBMEX

