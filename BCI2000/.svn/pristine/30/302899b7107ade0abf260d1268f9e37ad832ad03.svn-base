<!DOCTYPE html>
<html lang="en" dir="ltr">
<head>
<meta charset="UTF-8"/>
<title>Programming Reference:GenericFilter Class - BCI2000 Help</title>
<link rel='shortcut icon' href='../../rsrc/favicon.ico' />
<style type='text/css'>
html { font-size:95%; font-family:arial,helvetica,sans-serif }
.printfooter { display:none }
#tocmain { font-size:81%; font-weight:bold; color:black; background-color:white; border:1px solid black; padding:1em; z-index:10; position:fixed; left:-1px; top:-1px; width:150px; }
#tocmain a { color:blue; text-decoration:none }
#tocmain ul { margin:0 0 0 0.4em; padding:0.1em 0 0 0.1em; list-style-position:outside; list-style-type:disc }
#tocmain li { text-indent:0; margin:0 0 0 1em; padding: 0 0 0 0 }
#tocmain p { margin:0; padding:0.1em 0 0 0.1em }
#tocmain .toc1 { margin-left:1.25em; }
#tocmain .toc2 { margin-left:2.25em; }
#tocmain .toc3 { margin-left:3.25em; }
#article { font-size:91%; position:absolute; left:200px; right:0; padding:1em; margin:0 }
</style>
</head>
<body>
 <div id='tocmain'>
 <a href='Main_Page.html'><img src='../../rsrc/bci2000logo.svg' alt='[Main Page]' /></a> <hr class="sep" /><p class="toc0"><a href="User_Tutorial%253ABCI2000_Tour.html">GettingStarted</a></p><ul></ul><p class="toc0"><a href="User_Reference%253AContents.html">User Manual</a></p><ul></ul><p class="toc0"><a href="Technical_Reference%253AContents.html">Technical Reference</a></p><ul></ul><p class="toc0"><a href="Programming_Reference%253AContents.html">Programming Manual</a></p><ul><li class="toc1">Concepts</li><ul><li class="toc2"><a href="Programming_Reference%253AFilter_Chain.html">Filter Chain</a></li><li class="toc2"><a href="Programming_Reference%253ASignals.html">Signals</a></li><li class="toc2"><a href="Programming_Reference%253AError_Handling.html">Error Handling</a></li><li class="toc2"><a href="Programming_Reference%253ALocalization.html">Localization</a></li><li class="toc2"><a href="Programming_Reference%253ARapid_Development.html">Rapid Development</a></li></ul><li class="toc1">Reference</li><ul><li class="toc2">GenericFilter</li><li class="toc2"><a href="Programming_Reference%253AEnvironment_Class.html">Environment</a></li><li class="toc2"><a href="Programming_Reference%253AGenericVisualization_Class.html">GenericVisualization</a></li><li class="toc2"><a href="Programming_Reference%253AErrors_and_Warnings.html">Errors and Warnings</a></li><li class="toc2"><a href="Programming_Reference%253ADebug_Output.html">Debug Output</a></li></ul><li class="toc1">Data Acquisition</li><ul><li class="toc2"><a href="Programming_Reference%253AGenericADC_Class.html">GenericADC</a></li></ul><li class="toc1">Data Storage</li><ul><li class="toc2"><a href="Programming_Reference%253AGenericFileWriter_Class.html">GenericFileWriter</a></li><li class="toc2"><a href="Programming_Reference%253ABCI2000FileReader_Class.html">BCI2000FileReader</a></li></ul><li class="toc1">Signal Processing</li><ul><li class="toc2"><a href="Programming_Reference%253AIIRFilterBase_Class.html">IIR Filters</a></li></ul><li class="toc1">Application Modules</li><ul><li class="toc2"><a href="Programming_Reference%253AApplicationBase_Class.html">ApplicationBase</a></li><li class="toc2"><a href="Programming_Reference%253AFeedbackTask_Class.html">FeedbackTask</a></li><li class="toc2"><a href="Programming_Reference%253AStimulusTask_Class.html">StimulusTask</a></li><li class="toc2"><a href="Programming_Reference%253A3D_API.html">3D API</a></li></ul><li class="toc1">Howtos</li><ul><li class="toc2"><a href="Programming_Howto%253ABuilding_BCI2000.html">Building BCI2000</a></li><li class="toc2"><a href="Programming_Howto%253ASVN_Client_Setup.html">SVN Client Setup</a></li><li class="toc2"><a href="Programming_Howto%253AUsing_TortoiseSVN.html">Using TortoiseSVN</a></li></ul><li class="toc1"><a href="Programming_FAQ.html">FAQ</a></li><li class="toc1">Tutorials</li><ul><li class="toc2"><a href="Programming_Tutorial%253AImplementing_a_Data_Acquisition_Module.html">Data Acquisition</a></li><li class="toc2"><a href="Programming_Tutorial%253AImplementing_a_Signal_Processing_Filter.html">Signal Processing</a></li><li class="toc2"><a href="Programming_Tutorial%253AImplementing_a_Matlab-based_Filter.html">Matlab Signal Processing</a></li></ul></ul><p class="toc0"><a href="Contributions%253AContents.html">Contributions</a></p><ul></ul><hr class="sep" /><p class="toc0"><a href="BCI2000_Glossary.html">BCI2000 Glossary</a></p> </div>
 <div id='article'>
 <h1 class = "pagetitle">GenericFilter Class</h1>
 <p class = "subtitle">Programming Reference</p>
 <hr class = "sep" />
 <div id="mw-content-text" lang="en" dir="ltr" class="mw-content-ltr"><div class="mw-parser-output"><div id="toc" class="toc" role="navigation" aria-labelledby="mw-toc-heading"><input type="checkbox" role="button" id="toctogglecheckbox" class="toctogglecheckbox" style="display:none" /><div class="toctitle" lang="en" dir="ltr"><h2 id="mw-toc-heading">Contents</h2><span class="toctogglespan"><label class="toctogglelabel" for="toctogglecheckbox"></label></span></div>
<ul>
<li class="toclevel-1 tocsection-1"><a href="Programming_Reference%253AGenericFilter_Class.html#The_GenericFilter_class"><span class="tocnumber">1</span> <span class="toctext">The GenericFilter class</span></a></li>
<li class="toclevel-1 tocsection-2"><a href="Programming_Reference%253AGenericFilter_Class.html#Required_Members"><span class="tocnumber">2</span> <span class="toctext">Required Members</span></a>
<ul>
<li class="toclevel-2 tocsection-3"><a href="Programming_Reference%253AGenericFilter_Class.html#Publish"><span class="tocnumber">2.1</span> <span class="toctext">Publish</span></a></li>
<li class="toclevel-2 tocsection-4"><a href="Programming_Reference%253AGenericFilter_Class.html#Preflight"><span class="tocnumber">2.2</span> <span class="toctext">Preflight</span></a></li>
<li class="toclevel-2 tocsection-5"><a href="Programming_Reference%253AGenericFilter_Class.html#Initialize"><span class="tocnumber">2.3</span> <span class="toctext">Initialize</span></a></li>
<li class="toclevel-2 tocsection-6"><a href="Programming_Reference%253AGenericFilter_Class.html#Process"><span class="tocnumber">2.4</span> <span class="toctext">Process</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-7"><a href="Programming_Reference%253AGenericFilter_Class.html#Optional_Member_Functions"><span class="tocnumber">3</span> <span class="toctext">Optional Member Functions</span></a>
<ul>
<li class="toclevel-2 tocsection-8"><a href="Programming_Reference%253AGenericFilter_Class.html#AutoConfig"><span class="tocnumber">3.1</span> <span class="toctext">AutoConfig</span></a></li>
<li class="toclevel-2 tocsection-9"><a href="Programming_Reference%253AGenericFilter_Class.html#StartRun"><span class="tocnumber">3.2</span> <span class="toctext">StartRun</span></a></li>
<li class="toclevel-2 tocsection-10"><a href="Programming_Reference%253AGenericFilter_Class.html#StopRun"><span class="tocnumber">3.3</span> <span class="toctext">StopRun</span></a></li>
<li class="toclevel-2 tocsection-11"><a href="Programming_Reference%253AGenericFilter_Class.html#Resting"><span class="tocnumber">3.4</span> <span class="toctext">Resting</span></a></li>
<li class="toclevel-2 tocsection-12"><a href="Programming_Reference%253AGenericFilter_Class.html#Halt"><span class="tocnumber">3.5</span> <span class="toctext">Halt</span></a></li>
<li class="toclevel-2 tocsection-13"><a href="Programming_Reference%253AGenericFilter_Class.html#Destructor"><span class="tocnumber">3.6</span> <span class="toctext">Destructor</span></a></li>
<li class="toclevel-2 tocsection-14"><a href="Programming_Reference%253AGenericFilter_Class.html#AllowsVisualization"><span class="tocnumber">3.7</span> <span class="toctext">AllowsVisualization</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-15"><a href="Programming_Reference%253AGenericFilter_Class.html#Rules_for_Parameter_and_State_access"><span class="tocnumber">4</span> <span class="toctext">Rules for Parameter and State access</span></a></li>
</ul>
</div>

<h2><span class="mw-headline" id="The_GenericFilter_class">The <tt>GenericFilter</tt> class</span></h2>
<p><tt>GenericFilter</tt> is a base class that provides a programming
interface for all user code inside the core modules of this BCI2000
implementation.
Programming your own data acquisition module, your own filter inside
Signal Processing, or your own application, implies deriving your
own
class from <tt>GenericFilter</tt>.
<tt>GenericFilter</tt>'s member functions represent the various
initialization and processing events that occur during system startup
and operation (see <a href="Technical_Reference%253AStates_of_Operation.html" title="Technical Reference:States of Operation">Technical Reference:States of Operation</a>).
Your own filter code <i>must</i>  implement its own
versions of some of these member functions:
</p>
<h2><span class="mw-headline" id="Required_Members">Required Members</span></h2>
<h3><span class="mw-headline" id="Publish">Publish</span></h3>
<p>The <i>Publish</i> function publishes the parameters and states your filter wants to introduce into the system (the <tt>BEGIN_...</tt> and <tt>END_...</tt> macros handle the actual function calls): 
</p>
<pre>void
 MyFilter::Publish()
 {
   BEGIN_PARAMETER_DEFINITIONS
     "MySection int MyParam= 1 "
       "0 0 3 // This is range-checked between 0 and 3",
     "MySection float MyOtherParam= 0.1 "
       "0&#160;%&#160;% // This is not automatically range-checked",
   END_PARAMETER_DEFINITIONS

   BEGIN_STATE_DEFINITIONS
     "MyState 1 0",
   END_STATE_DEFINITIONS

   BEGIN_STREAM_DEFINITIONS
     "MyStream 1 0",
   END_STREAM_DEFINITIONS
 } </pre>
<p>The data between the <code>BEGIN_...</code> and <code>END_...</code> macros are lists of comma-separated C-strings, which are additionally broken across lines to improve readability. For the compiler, anything is fine here that is allowed between the curly braces in
</p>
<pre>const char* array[] = { "entry 1", "entry 2", "entry 3", };
</pre>
<p>For successful filter instantiation at runtime, the strings must also be valid <a href="Technical_Reference%253AParameter_Definition.html" title="Technical Reference:Parameter Definition">parameter</a> and <a href="Technical_Reference%253AState_Definition.html" title="Technical Reference:State Definition">state definitions</a>.
</p><p><b>NOTE:</b> Traditionally, parameters and states have been published from inside a filter's constructor. For more flexibility, a separate <code>Publish()</code> function has been introduced. For backward compatibility, parameters and states may still be published from the constructor, but this is deprecated for new code.
</p>
<h3><span class="mw-headline" id="Preflight">Preflight</span></h3>
<p>The <tt>Preflight</tt> function checks whether the preconditions for successful operation are met. This function is called whenever parameter values are re-applied, i.e., whenever the user presses "Set Config" in the operator window. If <tt>Preflight</tt> does not report an error, this counts as a statement that <tt>Initialize</tt> and <tt>Process</tt> will work properly with the current parameters. The first argument to <tt>Preflight</tt> will inform you about what kind of input signal your filter is going to receive, and your filter is expected to report the properties of its output signal via the second parameter:
</p>
<pre> void MyFilter::Preflight( const SignalProperties&amp; Input,
                                 SignalProperties&amp; Output ) const
 {
   PreflightCondition( Parameter( "MyOtherParam" ) &gt; 0.0 );
   PreflightCondition( Input.Channels() &gt; 0 );
   Output = Input;
 } </pre>
<p>Note that the <tt>const</tt> keyword following the function argument list forbids altering any data member of your filter object. This avoids diffusion of initialization code from <tt>Initialize</tt> into <tt>Preflight</tt>. If you have your own sub-objects instantiated and maintained by your filter, you should provide them with their own <tt>Preflight() const</tt> member functions, and call these from your filter's <tt>Preflight</tt>.
</p><p>In the same way as other BCI2000 code does, the <tt>Preflight()</tt> function reports errors by writing descriptive text into the <a href="Programming_Reference%253AError_Handling.html#Reporting_Errors" title="Programming Reference:Error Handling"><tt>bcierr</tt> output stream</a>.
</p>
<h3><span class="mw-headline" id="Initialize">Initialize</span></h3>
<p><tt>Initialize</tt> is called after a successful <tt>Preflight</tt>. Thus, it may safely omit all checks related to parameter consistency. In <tt>Initialize</tt>, your filter's data members are set to the values implied by the user's choices, or to the initial values required for the filter's operation:
</p>
<pre> void MyFilter::Initialize( const SignalProperties&amp; Input,
                            const SignalProperties&amp; Output )
 {
   mMyParam = Parameter( "MyParam" );
   mMyOtherParam = Parameter( "MyOtherParam" );
   mCount = 0;
 } </pre>
<h3><span class="mw-headline" id="Process">Process</span></h3>
<p>The <tt>Process</tt> function is called once for each block of EEG data. It receives an input in its first argument, and sets its output signal to values resulting from filter operation. In the current BCI2000 implementation, there is a single chain of filters--one filter's output signal is the next filter's input. A filter which does not perform any modification to the signal (e.g., a statistics filter) needs to copy its input signal into the output signal, as in the example:
</p>
<pre> void MyFilter::Process( const GenericSignal&amp; Input,
                               GenericSignal&amp; Output )
 {
   if( Input( 0, 0 ) &gt; mMyOtherParam )
     ++mCount;
   Output = Input;
 } </pre>
<p>The <tt>Process</tt> function should not acquire or release resources (opening/closing files, allocating memory, etc). Natural places for such operations are the <tt>Initialize</tt>, <tt>StartRun</tt>, and <tt>StopRun</tt> member functions.
</p>
<h2><span class="mw-headline" id="Optional_Member_Functions">Optional Member Functions</span></h2>
<p>Other member functions are <i>optional;</i>  you may decide whether
you
override their default implementation with your own version,
depending on what your filter needs to do:
</p>
<h3><span class="mw-headline" id="AutoConfig">AutoConfig</span></h3>
<p><tt>AutoConfig</tt> is called each time the configuration has changed. It allows you to set parameter values according to your component's needs, and to perform initialization that is required in order to determine parameter values.
</p><p><tt>AutoConfig</tt> may be implemented by any component, but it is typically used by components that interface to hardware devices, such as EEG amplifiers. In <tt>AutoConfig</tt>, the component may set up a persistent connection to its device, and obtain information about the device's configuration. Then, this information may be used to adapt the component's parameter settings accordingly.
</p><p>From <tt>AutoConfig</tt>, only such parameters may be adapted that have been published in the component's own <tt>Publish</tt> method. Further, <tt>AutoConfig</tt> parameter changes will be silently ignored unless a parameter's value is set to "auto", allowing user choices to override auto configuration. Typically, a component's auto-configurable parameters should be published with "auto" as a value (which should be the only entry in case of list- or matrix-valued parameters).
</p><p>In case of parameters which are declared "readonly" (from the user's perspective), changes during <tt>AutoConfig</tt> will also persist if the original parameter value was empty, i.e. those parameters need not be set to "auto" explicitly.
</p><p>When there are multiple auto-configurable parameters that depend upon one another, the number of cases to be dealt with will grow exponentially with the number of parameters: each single parameter may have a value assigned by the user, or may have been set to auto-configured, resulting in <tt>(2^N)-1</tt> distinct auto-configuration cases for <tt>N</tt> such parameters. Thus, code that needs to deal with each of those cases explicitly would be difficult to write and maintain. To improve scaling of effort, parameter access in <tt>AutoConfig</tt> follows rules which may be difficult to grasp at first but greatly simplify the task of writing <tt>AutoConfig</tt> code:
</p>
<ul><li>Parameter assignment persists throughout the <tt>AutoConfig</tt> function, as if the parameter in question had been set to "auto" by the user.</li>
<li>An additional <tt>ActualParameter()</tt> accessor function provides read-only access to a parameter's current value, i.e. the user's setting, "auto", or a previously assigned auto-configured value.</li></ul>
<p>As an example, consider two interdependent parameters, "MyParam" and "MyOtherParam". If "MyParam" has been user-configured, but "MyOtherParam" is set to "auto", "MyOtherParam's" value needs to be set to a value that depends on the value of "MyParam", and vice versa. Altogether, four cases are possible, and three of those require auto configuration. Using the rules above, we may write <tt>AutoConfig</tt> code that only grows linearly with the number of parameters involved, rather than exponentially, in the following way:
</p>
<ul><li>First, assign sane and consistent initial values to all parameters,</li>
<li>then, assign each parameter again as if the assigned parameter were the only one to be auto-configured, using the remaining parameters' actual values.</li></ul>
<pre>Parameter("MyParam") = ...;
// omit redundant initial assignment of MyOtherParam
Parameter("MyOtherParam") = SomeFunction( ActualParameter("MyParam") );
Parameter("MyParam") = InverseOfSomeFunction( ActualParameter("MyOtherParam") );
</pre>
<p>In case of three interdependent parameters, we have:
</p>
<pre>Parameter("MyParam1") = ...;
Parameter("MyParam2") = ...;
// omit redundant initial assignment of MyParam3
Parameter("MyParam3") = SomeFunction12( ActualParameter("MyParam1"), ActualParameter("MyParam2") );
Parameter("MyParam1") = SomeFunction23( ActualParameter("MyParam2"), ActualParameter("MyParam3") );
Parameter("MyParam2") = SomeFunction13( ActualParameter("MyParam1"), ActualParameter("MyParam3") );
</pre>
<h3><span class="mw-headline" id="StartRun">StartRun</span></h3>
<p><tt>StartRun</tt> is called when the system enters the running state. As opposed to <tt>Initialize</tt>, which is the place for tasks that need to be performed on each parameter change, <tt>StartRun</tt> is provided for tasks that need to be performed each time the user clicks "Run" or "Resume" in the operator window. As a canonical example, the <tt>DataIOFilter</tt> opens a new <tt>.dat</tt> file from its <tt>StartRun</tt> member function.
</p>
<h3><span class="mw-headline" id="StopRun">StopRun</span></h3>
<p><tt>StopRun</tt> is called each time the system leaves the running state, entering the suspended state. Typically, this happens whenever the user clicks "Suspend" in the operator window. The <tt>DataIOFilter</tt> provides an example for its usage: This filter closes the current <tt>.dat</tt> file from its <tt>StopRun</tt> member function.
</p><p><tt>StopRun</tt> is also the only function from which a filter may change a parameter value. Any parameter changes inside <tt>StopRun</tt> will propagate to the other modules without any explicit request from your side.
</p>
<h3><span class="mw-headline" id="Resting">Resting</span></h3>
<p><tt>Resting</tt> is called instead of <tt>Process</tt> while the system is in suspended state.
Typically, <tt>Resting</tt> is called repeatedly for filters inside source modules; in the remaining modules, <tt>Resting</tt> is called once when the system enters suspended state. Except that it is called at least once in suspended state, you should not make any assumption how often <tt>Resting</tt> is called.
</p>
<h3><span class="mw-headline" id="Halt">Halt</span></h3>
<p>The <tt>Halt</tt> function is called before any reconfiguration of the system takes place. If your filter initiates asynchronous operations such as playing a sound file, acquiring EEG data, or executing threads, its <tt>Halt</tt> member function should terminate all such operations immediately. Failure to do so might result in a non-responding module, or in other errors difficult to track down. For descendants of <tt>GenericADC</tt>, implementing the <tt>Halt</tt> function is mandatory. 
</p>
<h3><span class="mw-headline" id="Destructor">Destructor</span></h3>
<p>Your filter's <i>Destructor</i>  should free all resources acquired in the Constructor or in <tt>Initialize</tt>. In many cases, freeing of resources will be done automatically if you use direct members instead of pointers, removing the need for a destructor. However, if your filter has a non-empty <tt>Halt</tt> function, it needs a destructor that calls <tt>Halt</tt> - this can not be done from the base class destructor because overridden virtual functions cannot be called from base class constructors or destructors.
</p>
<pre> MyFilter::~MyFilter()
 {
   Halt();
 } </pre>
<h3><span class="mw-headline" id="AllowsVisualization">AllowsVisualization</span></h3>
<p>Unlike the previous members of <code>GenericFilter</code>, this function represents a property rather than an event.
Through its return value, a filter can decide whether its output may be offered for visualization by the framework, i.e. whether it appears in the Processing Stages section in the operator's Visualize tab.
</p><p><code>AllowsVisualization</code> is called once at instantiation, and then after each Initialize() that occurs.
If it returns false at instantiation, no visualization parameter is created for the filter.
If it returns false at initialization time, no default visualization is displayed,
independently of the visualization parameter's value.
The filter itself may still maintain its own visualization parameters and <a href="Programming_Reference%253AGenericVisualization_Class.html" title="Programming Reference:GenericVisualization Class">GenericVisualization</a> object.
</p>
<h2><span class="mw-headline" id="Rules_for_Parameter_and_State_access">Rules for Parameter and State access</span></h2>
<p>For consistent and robust overall system operation, it is crucial that individual filters actually check <a href="BCI2000_Glossary.html#Parameter" title="BCI2000 Glossary">parameter</a> values and <a href="BCI2000_Glossary.html#States" title="BCI2000 Glossary">state</a> accessibility from their <code>Preflight()</code> function. To support this idea, the BCI2000 framework imposes a set of rules to parameter and state access:
</p>
<ul><li>Parameters and states accessed during initialization or processing <i>must</i> be accessed during the preflight phase. Otherwise, an error message will be displayed when the first access occurs.</li>
<li>To avoid pointless cludging of the <code>Preflight()</code> function, there are some exceptions to this rule:
<ul><li>States defined in a filter's constructor are known to be present, and thus need not be accessed from that filter's <code>Preflight()</code> function.</li>
<li>Parameters defined in a filter's <code>Publish()</code> function will be range-checked automatically if any of their <code>LowRange</code> or <code>HighRange</code> <a href="Technical_Reference%253AParameter_Definition.html" title="Technical Reference:Parameter Definition">properties</a> is set, and need not be accessed explicitly from <code>Preflight()</code>.</li>
<li>To disable automatic range checking, set both these properties to the empty string in your <a href="Technical_Reference%253AParameter_Definition.html" title="Technical Reference:Parameter Definition">parameter definition line</a>:<br /><code>MySection int MyParam= 1 0&#160;%&#160;% // a parameter that is not automatically range-checked</code><br />This implies that you need to implement your own range-check in <code>Preflight()</code>. If there are no actual constraints on the parameter's value, just add a line <code>Parameter( "MyParam" );</code> to the filter's <code>Preflight()</code> function.</li></ul></li>
<li><a href="User_Reference%253AExpression_Syntax.html" title="User Reference:Expression Syntax">Expressions</a> may involve state names, and thus need to be evaluated in order to check whether referred-to states are present. Just add a line <br /><code>Expression( Parameter( "MyExpressionParam" ) ).Evaluate();</code><br /> to the filter's <code>Preflight()</code> function.</li></ul>
<!-- 
NewPP limit report
Cached time: 20230524175546
Cache expiry: 86400
Dynamic content: false
Complications: []
CPU time usage: 0.024 seconds
Real time usage: 0.027 seconds
Preprocessor visited node count: 78/1000000
Post‐expand include size: 0/2097152 bytes
Template argument size: 0/2097152 bytes
Highest expansion depth: 2/40
Expensive parser function count: 0/100
Unstrip recursion depth: 0/20
Unstrip post‐expand size: 1211/5000000 bytes
-->
<!--
Transclusion expansion time report (%,ms,calls,template)
100.00%    0.000      1 -total
-->

<!-- Saved in parser cache with key wikidb-bci_:pcache:idhash:1447-0!canonical and timestamp 20230524175546 and revision id 9872
 -->
</div></div><div class="printfooter">
Retrieved from "<a dir="ltr" href="http://www.bci2000.org/mediawiki/index.php?title=Programming_Reference:GenericFilter_Class&amp;oldid=9872">http://www.bci2000.org/mediawiki/index.php?title=Programming_Reference:GenericFilter_Class&amp;oldid=9872</a>"</div>
 </div>
</body>
</html>